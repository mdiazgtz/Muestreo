# -*- coding: utf-8 -*-
"""Codigo_Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dFHTH9n8gtDwZ66NXjUUOyLhdLFdcazh
"""

import pandas as pd
import statistics as st
import matplotlib.pyplot as plt
import numpy as np

"""Activamos Google Drive para importar las bases de datos"""

from google.colab import drive
drive.mount('/content/drive')

"""Importamos las bases de datos a utilizar"""

B2019_I = pd.read_csv('/content/drive/MyDrive/Muestreo/1 - Datos Limpiados/2019-I.csv')
B2019_II = pd.read_csv('/content/drive/MyDrive/Muestreo/1 - Datos Limpiados/2019-II.csv')
B2020_I = pd.read_csv('/content/drive/MyDrive/Muestreo/1 - Datos Limpiados/2020-I.csv')
B2020_II = pd.read_csv('/content/drive/MyDrive/Muestreo/1 - Datos Limpiados/2020-II.csv')
B2021_I = pd.read_csv('/content/drive/MyDrive/Muestreo/1 - Datos Limpiados/2021-I.csv')

"""**Objetivos a trabajar en este cuaderno**

1. Tiempo promedio de asesoría (por semestre)

2. Total de tiempo de asesoría (por semestre)

3. Proporción de materias (por semestre)

4. Total de alumnos por carrera (por semestre)

**Tipos de gráficas a realizar en**

1. Histograma de frecuencias

2. Gráfico de barras horizontal

3. Gráfico de pastel

4. Gráfico de barras vertical apilado

El gráfico del punto 2 es un solo gráfico que contiene el total de tiempo de asesoría por semestre.

Los gráficos del punto 1 y 3, es decir Tiempo promedio de asesoría y Proporción de materias, deberán mostrar en una misma ventana los cinco gráficos.

Toda la información encontrada en cada punto debe ir contenida en una tabla. Por ejemplo, para el tiempo promedio de asesoría.

|Semestre|Tiempo promedio de asesoría|
|--------|---------------------------|
|$$2019-I$$|$$XXX$$|
|$$2019-II$$|$$XXX$$|
|$$2020-I$$|$$XXX$$|
|$$2020-II$$|$$XXX$$|
|$$2021-I$$|$$XXX$$|

#Limpieza y filtrado

##$2019 - I$

### Limpieza general de la base de datos
"""

B2019_I.head(4)

"""**NOTA : Al momento de la limpieza me di cuenta que Calculo se repetia dos veces y esto sucedió porque se encontraba «Calculo » y «Calculo». El siguiente código es para resolver ese problema**"""

B2019_Calculo = B2019_I.loc[B2019_I.loc[:,'UNIDAD DE APRENDIZAJE '] == 'Calculo '] #FILTRO AQUELLOS QUE TENGAN CALCULO CON ESPACIO Y LO ASIGNO A B2019_Calculo
B2019_Calculo['UNIDAD DE APRENDIZAJE '].replace('Calculo ','Calculo',inplace = True) #MODIFICO TODOS ESTOS DATOS QUITANDO EL ESPACIO Y MODIFICO B2019_Calculo

B2019_I = pd.concat([B2019_I.drop(list(B2019_Calculo.index)),B2019_Calculo],axis=0) #AL DATA FRAME ORIGINAL LE QUITO LAS FILAS QUE TENIAN ESTE PROLEMA Y LO CONCATENO CON EL DF ARREGLADO

"""Solamente nos quedaremos con la información correspondiente a las carreras dadas en la facultad FCFM."""

B2019_I = B2019_I[B2019_I.CARRERA.isin(['LM','LA','LCC','LSTI','LF','LMAD'])]

"""### Limpieza para el tiempo y gráfico (promedio y total)

Nosotros queremos calcular la media del tiempo de asesoría, primero hacemos una clasificación del tiempo pues por la manera en que estan estructurados algunos datos hace imposible la limpieza general dando como resultado tiempos negativos que no son lógicos o tiempos demasiados extensos. Por tanto la clasifación que tomaremos son aquellos tiempos de asesoría mayores a 5 minutos pero menores a 360 minutos (6 horas)

Este filtrado lo asignamos a la variable 'B2019_I_Tiempo'
"""

B2019_I_Tiempo = B2019_I.loc[ B2019_I.loc[:,'TIEMPO (MIN)'] >= 5]
B2019_I_Tiempo = B2019_I_Tiempo.loc[ B2019_I_Tiempo.loc[:,'TIEMPO (MIN)'] <= 360 ]

"""Calculamos el promedio de tiempo de asesoría con la función mean y lo asignamos a la variable 'B2019_I_Promedio_Tiempo'"""

B2019_I_Promedio_Tiempo = B2019_I_Tiempo.loc[:,'TIEMPO (MIN)'].mean()
B2019_I_Promedio_Tiempo

"""Para realizar el histograma de frecuencias solamente filtramos la columna 'TIEMPO (MIN)' y lo asignamos a la variable 'B2019_I_Hist_Tiempo'"""

B2019_I_Hist_Tiempo = B2019_I_Tiempo.loc[:,'TIEMPO (MIN)']

"""Para calcular el total de tiempo de asesoría usamos la función sum y lo asignamos a la variable 'B2019_I_Total_Tiempo'"""

B2019_I_Total_Tiempo = B2019_I_Tiempo.loc[:,'TIEMPO (MIN)'].sum()
B2019_I_Total_Tiempo

"""### Limpieza para gráfico de pastel

Queremos una proporción de materias, por lo tanto extraemos la columna «UNIDAD DE APRENDIZAJE» y lo asignamos a la variable B2019_I_UA.
"""

B2019_I_UA = B2019_I.loc[:,'UNIDAD DE APRENDIZAJE '].value_counts().to_frame() #CONTABILIZAMOS CUANTAS VECES SE REPITE CADA MATERIA Y LO HACEMOS DATA FRAME
B2019_I_UA

"""Las materias que fueron solicitadas menos de 20 veces las agregaremos a la variable B_2019_I_UA_Otros, esto lo hacemos por estética del gráfico y **NO** por el cálculo de las proporciones."""

B2019_I_UA_Otros = B2019_I_UA.loc[ B2019_I_UA.loc[:,'UNIDAD DE APRENDIZAJE '] < 99 ]

"""Eliminamos del Data Frame B_2019_I_UA las materias que se solicitan menos de 20 veces"""

B2019_I_UA.drop(list(B2019_I_UA_Otros.index),inplace = True)

"""Añadimos la fila 'Otros' que indicará cuantas veces la proporción de materias con una frecuencia menor o igual a 20"""

B2019_I_UA.loc['Otros'] = B2019_I_UA_Otros.sum()

B2019_I_UA

"""### Limpieza para obtener la proporción de materias

Filtramos nuevamente la columna «UNIDAD DE APRENDIZAJE», contamos el número de veces que fue solicitado una sola materia
"""

B2019_I_UA2 = B2019_I.loc[:,'UNIDAD DE APRENDIZAJE '].value_counts().to_frame()
B2019_I_UA2

"""Contamos el número total de asesorías"""

B2019_I_UA2['UNIDAD DE APRENDIZAJE '].sum()

"""Añadimos una nueva columna a B2019_I_UA2 llamada "Proporción" que contenga la proporción de cada una de las materias"""

B2019_I_UA2['Proporcion'] = (B2019_I_UA2['UNIDAD DE APRENDIZAJE ']/B2019_I_UA2['UNIDAD DE APRENDIZAJE '].sum())*100

"""Asignamos a la variable «B2019_Proporcion_Materias» solamente la columna Proporción de la variable B2019_I_UA2"""

B2019_Proporcion_Materias = B2019_I_UA2.loc[:,'Proporcion'].to_frame()
B2019_Proporcion_Materias

"""### Limpieza para obtener el total de alumnos por carrera y el gráfico

Asignamos a la variable «B2019_Carrera» solamente la columna Carrera de la base de datos.
"""

B2019_Carrera = B2019_I.loc[:,'CARRERA']

"""Asignamos a la variable «B2019_Carrera_Total» el conteo del numero de veces que se repite cada carrera"""

B2019_Carrera_Total = B2019_Carrera.value_counts().to_frame()

B2019_Carrera_Total

"""##$2019 - II$

### Limpieza general de la base de datos
"""

B2019_II.head(4)

"""Solamente nos quedaremos con la información correspondiente a las carreras dadas en la facultad FCFM."""

B2019_II = B2019_II[B2019_II.CARRERA.isin(['LM','LA','LCC','LSTI','LF','LMAD'])]

"""Vamos a leer los tipos de datos que hay en la base de datos"""

B2019_II.info()

"""Notemos que la columna 'TIEMPO (MIN)' tiene datos tipo 'object', es decir, texto. Convertimos los datos de esta columna en datos tipo 'float'"""

B2019_II.drop(1396,axis = 0,inplace = True)

B2019_II['TIEMPO (MIN)'] = B2019_II['TIEMPO (MIN)'].astype(float)

"""### Limpieza para el tiempo y gráfico (promedio y total)

Nosotros queremos calcular la media del tiempo de asesoría, primero hacemos una clasificación del tiempo pues por la manera en que estan estructurados algunos datos hace imposible la limpieza general dando como resultado tiempos negativos que no son lógicos o tiempos demasiados extensos. Por tanto la clasifación que tomaremos son aquellos tiempos de asesoría mayores a 5 minutos pero menores a 360 minutos (6 horas)

Esto lo asignamos a la variable 'B2019_II_Tiempo'
"""

B2019_II_Tiempo = B2019_II.loc[ B2019_II.loc[:,'TIEMPO (MIN)'] >= 5 ]
B2019_II_Tiempo = B2019_II_Tiempo.loc[ B2019_II_Tiempo.loc[:,'TIEMPO (MIN)'] <= 360]

"""Calculamos el promedio de tiempo de asesoría con la función mean y lo asignamos a la variable 'B2019_II_Promedio_Tiempo'"""

B2019_II_Promedio_Tiempo = B2019_II_Tiempo.loc[:,'TIEMPO (MIN)'].mean()
B2019_II_Promedio_Tiempo

"""Para realizar el histograma de frecuencias solamente filtramos la columna 'TIEMPO (MIN)' y lo asignamos a la variable 'B2019_II_Hist_Tiempo'"""

B2019_II_Hist_Tiempo = B2019_II_Tiempo.loc[:,'TIEMPO (MIN)']

"""Para calcular el total de tiempo de asesoría usamos la función sum y lo asignamos a la variable 'B2019_II_Total_Tiempo'"""

B2019_II_Total_Tiempo = B2019_II_Tiempo.loc[:,'TIEMPO (MIN)'].sum()
B2019_II_Total_Tiempo

"""### Limpieza para el gráfico de pastel

Queremos una proporción de materias, por lo tanto extraemos la columna «UNIDAD DE APRENDIZAJE» y lo asignamos a la variable B2019_II_UA.
"""

B2019_II_UA = B2019_II.loc[:,'UNIDAD DE APRENDIZAJE '].value_counts().to_frame()

"""Las materias que fueron solicitadas menos de 20 veces las agregaremos a la variable B_2019_II_UA_Otros, esto lo hacemos por estética del gráfico y **NO** por el cálculo de las proporciones."""

B2019_II_UA_Otros = B2019_II_UA.loc[ B2019_II_UA.loc[:,'UNIDAD DE APRENDIZAJE '] <= 84 ]

"""Eliminamos del Data Frame B_2019_II_UA las materias que se solicitan menos de 20 veces"""

B2019_II_UA.drop(list(B2019_II_UA_Otros.index),inplace = True)

"""Añadimos la fila 'Otros' que indicará cuantas veces la proporción de materias con una frecuencia menor o igual a 20"""

B2019_II_UA.loc['Otros'] = B2019_II_UA_Otros.sum()

B2019_II_UA

"""### Limpieza para obtener la proporción de materias

Filtramos nuevamente la columna «UNIDAD DE APRENDIZAJE», contamos el número de veces que fue solicitado una sola materia
"""

B2019_II_UA2 = B2019_II.loc[:,'UNIDAD DE APRENDIZAJE '].value_counts().to_frame()

"""Contamos el número total de asesorías"""

B2019_II_UA2.loc[:,'UNIDAD DE APRENDIZAJE '].sum()

"""Añadimos una nueva columna a B2019_II_UA2 llamada "Proporción" que contenga la proporción de cada una de las materias"""

B2019_II_UA2['Proporcion'] = (B2019_II_UA2['UNIDAD DE APRENDIZAJE ']/B2019_II_UA2['UNIDAD DE APRENDIZAJE '].sum())*100

"""Asignamos a la variable «B2019_Proporcion_Materias_II» solamente la columna Proporción de la variable B2019_II_UA2"""

B2019_Proporcion_Materias_II = B2019_II_UA2.loc[:,'Proporcion'].to_frame()

B2019_Proporcion_Materias_II

"""### Limpieza para obtener el total de alumnos por carrera y el gráfico

Asignamos a la variable «B2019_II_Carrera» solamente la columna Carrera de la base de datos.
"""

B2019_II_Carrera = B2019_II.loc[:,'CARRERA']

"""Asignamos a la variable «B2019_II_Carrera_Total» el conteo del numero de veces que se repite cada carrera"""

B2019_II_Carrera_Total = B2019_II_Carrera.value_counts().to_frame()

B2019_II_Carrera_Total

"""## $2020 - I$

### Limpieza general de la base de datos
"""

B2020_I.head(4)

"""Como tenemos mas carreras y facultades , tenemos que sesgar a solo las carreras de la FCFM"""

B2020_I= B2020_I[B2020_I.Carrera.isin(['LM','LA','LCC','LSTI','LF','LMAD'])]

"""Ya teniendo solo las carreras de la FCFM, entonces ahora observamos que ninguna carrera se repite , por lo que no hay cambios y Solamente nos quedaremos con la información correspondiente a las carreras dadas en la facultad FCFM.

"""

B2020_I.loc[:,'Carrera'].value_counts()

"""Vamos a leer los tipos de datos que hay en la base de datos"""

B2020_I.info()

"""Notemos que la columna 'TIEMPO (MIN)' tiene datos tipo 'object', es decir, texto. Convertimos los datos de esta columna en datos tipo 'float'"""

B2020_I.loc[B2020_I.loc[:,'TIEMPO (MIN)']=='-1,298']

B2020_I.loc[B2020_I.loc[:,'TIEMPO (MIN)']=='-1,024']

B2020_I.loc[B2020_I.loc[:,'TIEMPO (MIN)']=='-1,440']

B2020_I.drop(259,axis = 0,inplace = True)

B2020_I.drop(261,axis = 0,inplace = True)

B2020_I.drop(302,axis = 0,inplace = True)

B2020_I.drop(447,axis = 0,inplace = True)

B2020_I['TIEMPO (MIN)'] = B2020_I['TIEMPO (MIN)'].astype(float)

"""### Limpieza para el tiempo y gráfico (promedio y total)

Nosotros queremos calcular la media del tiempo de asesoría, primero hacemos una clasificación del tiempo pues por la manera en que estan estructurados algunos datos hace imposible la limpieza general dando como resultado tiempos negativos que no son lógicos o tiempos demasiados extensos. Por tanto la clasifación que tomaremos son aquellos tiempos de asesoría mayores a 5 minutos pero menores a 360 minutos (6 horas)

Esto lo asignamos a la variable 'B2020_II_Tiempo'
"""

B2020_I_Tiempo = B2020_I.loc[ B2020_I.loc[:,'TIEMPO (MIN)'] >= 5 ]
B2020_I_Tiempo = B2020_I_Tiempo.loc[ B2020_I_Tiempo.loc[:,'TIEMPO (MIN)'] <= 360]

"""Calculamos el promedio de tiempo de asesoría con la función mean y lo asignamos a la variable 'B2020_I_Promedio_Tiempo'"""

B2020_I_Promedio_Tiempo = B2020_I_Tiempo.loc[:,'TIEMPO (MIN)'].mean()
B2020_I_Promedio_Tiempo

"""Para realizar el histograma de frecuencias solamente filtramos la columna 'TIEMPO (MIN)' y lo asignamos a la variable 'B2020_I_Hist_Tiempo'"""

B2020_I_Hist_Tiempo = B2020_I_Tiempo.loc[:,'TIEMPO (MIN)']

"""Para calcular el total de tiempo de asesoría usamos la función sum y lo asignamos a la variable 'B2020_I_Total_Tiempo'"""

B2020_I_Total_Tiempo = B2020_I_Tiempo.loc[:,'TIEMPO (MIN)'].sum()
B2020_I_Total_Tiempo

"""###Limpieza para gráfico de pastel

Como Queremos una proporción de materias, entonces extraemos la columna «Unidad de Aprendizaje» y lo asignamos a la variable B2020_I_UA.
"""

B2020_I_UA = B2020_I.loc[:,'Unidad de Aprendizaje'].value_counts().to_frame() #CONTABILIZAMOS CUANTAS VECES SE REPITE CADA MATERIA Y LO HACEMOS DATA FRAME
B2020_I_UA

"""Las materias que fueron solicitadas menos de 20 veces las agregaremos a la 
variable B_2020_I_UA_Otros, esto lo hacemos por estética del gráfico y NO por el cálculo de las proporciones.
"""

B2020_I_UA_Otros = B2020_I_UA.loc[ B2020_I_UA.loc[:,'Unidad de Aprendizaje'] <= 44 ]

"""Eliminamos del Data Frame B_2020_I_UA las materias que se solicitan menos de 20 veces"""

B2020_I_UA.drop(list(B2020_I_UA_Otros.index),inplace = True)

"""Añadimos la fila 'Otros' que indicará cuantas veces la proporción de materias con una frecuencia menor o igual a 20"""

B2020_I_UA.loc['Otros'] = B2020_I_UA_Otros.sum()

B2020_I_UA

"""###Limpieza para obtener la proporción de materias

Filtramos nuevamente la columna «Unidad de Aprendizaje», contamos el número de veces que fue solicitado una sola materia
"""

B2020_I_UA2 = B2020_I.loc[:,'Unidad de Aprendizaje'].value_counts().to_frame()
B2020_I_UA2

"""Contamos el número total de asesorías"""

B2020_I_UA2['Unidad de Aprendizaje'].sum()

"""Añadimos una nueva columna a B2020_I_UA2 llamada "Proporción" que contenga la proporción de cada una de las materias"""

B2020_I_UA2['Proporcion'] = (B2020_I_UA2['Unidad de Aprendizaje']/B2020_I_UA2['Unidad de Aprendizaje'].sum())*100

"""Asignamos a la variable «B2020_Proporcion_Materias» solamente la columna Proporción de la variable B2020_I_UA2"""

B2020_Proporcion_Materias = B2020_I_UA2.loc[:,'Proporcion'].to_frame()
B2020_Proporcion_Materias

"""###Limpieza para obtener el total de alumnos por carrera y el gráfico

Asignamos a la variable «B2020_Carrera» solamente la columna Carrera de la base de datos.
"""

B2020_Carrera = B2020_I.loc[:,'Carrera']

"""Asignamos a la variable «B2020_Carrera_Total» el conteo del numero de veces que se repite cada carrera"""

B2020_I_Carrera_Total = B2020_Carrera.value_counts().to_frame()

B2020_I_Carrera_Total

"""##$2020 - II$

### Limpieza general de la base de datos
"""

B2020_II.head(4)

"""Solamente nos quedaremos con la información correspondiente a las carreras dadas en la facultad FCFM"""

B2020_II = B2020_II[B2020_II.Carrera.isin(['LM','LA','LCC','LSTI','LF','LMAD'])]

"""Vamos a leer los tipos de datos que tiene nuestra base de datos

"""

B2020_II.info()

"""Notemos que la columna 'TIEMPO (MIN)' tiene datos tipo object, es decir de tipo texto. Convertimos los datos de esta columna en datos tipo 'float'"""

B2020_II.rename(columns = {'TIEMPO (MIN)':'TIEMPO_(MIN)'}, inplace = True)

B2020_II.loc[B2020_II.loc[:,'TIEMPO_(MIN)']== '-1,028']

"""Eliminamos esta hilera """

B2020_II.drop(292,axis = 0,inplace= True)

B2020_II['TIEMPO_(MIN)'] = B2020_II['TIEMPO_(MIN)'].astype(float)

B2020_II.info()

"""Notamos que la columna TIEMPO_(MIN) ahora es de tipo flotante por lo cual ya podemos trabajar con ella

### Limpieza para el tiempo y gráfico (promedio y total)

Queremos calcular la media del tiempo de asesoría, clasificamos el tiempo puesto que la base de datos tiene algunos datos que nos hacen imposible realizar la limpieza (como por jemplo algunos datos dan tiempos negativos o muy extensos). Por lo cual decidimos clasificar el tiempo como mayor a 5 minutos y a su vez menor a 360 minutos (6 horas).

Este filtrado lo asignamos a la variable 'B2020_II_Tiempo'
"""

B2020_II_Tiempo = B2020_II.loc[ B2020_II.loc[:,'TIEMPO_(MIN)'] >= 5]

B2020_II_Tiempo = B2020_II_Tiempo.loc[ B2020_II_Tiempo.loc[:,'TIEMPO_(MIN)'] <= 360]

"""Calculamos el promedio de tiempo de asesoría con la función mean y lo asignamos a la variable 'B2020_II_Promedio_Tiempo'"""

B2020_II_Promedio_Tiempo = B2020_II_Tiempo.loc[:,'TIEMPO_(MIN)'].mean()

B2020_II_Promedio_Tiempo

"""Para realizar el histograma de frecuencias solamente filtramos la columna 'TIEMPO_(MIN)' y lo asignamos a la variable 'B2020_II_Hist_Tiempo'"""

B2020_II_Hist_Tiempo = B2020_II_Tiempo.loc[:,'TIEMPO_(MIN)']

"""Para calcular el total de tiempo de asesoría usamos la función sum y lo asignamos a la variable 'B2020_II_Total_Tiempo'

"""

B2020_II_Total_Tiempo = B2020_II_Tiempo.loc[:,'TIEMPO_(MIN)'].sum()

B2020_II_Total_Tiempo

"""### Limpieza para el gráfico de pastel

Queremos una proporción de materias, por lo tanto extraemos la columna UNIDAD DE APRENDIZAJE y lo asignamos a la variable B2020_II-UA.
"""

B2020_II_UA = B2020_II.loc[:,'Unidad de Aprendizaje'].value_counts().to_frame()

B2020_II_UA

"""Las materias que fueron solicitadas menos de 20 veces las agregamos a la variable B_2020_II_UA_Otros, esto lo hacemos por estética del gráfico y NO por el cálculo de las proporciones."""

B2020_II_UA_Otros = B2020_II_UA.loc[ B2020_II_UA.loc[:,'Unidad de Aprendizaje'] < 30 ]

"""Eliminamos del Data Frame B_2020_II_UA las materias que se solicitan menos de 20 veces"""

B2020_II_UA.drop(list(B2020_II_UA_Otros.index),inplace = True)

"""Añadimos la fila 'Otros' que indicará cuantas veces la proporción de materias con una frecuencia menor o igual a 20"""

B2020_II_UA.loc['Otros'] = B2020_II_UA_Otros.sum()

B2020_II_UA

"""### Limpieza para obtener la proporción de materias

Filtramos nuevamente la columna UNIDAD DE APRENDIZAJE, contamos el número de veces que fue solicitado una sola materia
"""

B2020_II_UA2 = B2020_II.loc[:,'Unidad de Aprendizaje'].value_counts().to_frame()

B2020_II_UA2

"""Contamos el número total de asesorías """

B2020_II_UA2.loc[:,'Unidad de Aprendizaje'].sum()

"""Añadimos una nueva columna a B2020_II_UA2 llamada "Proporción" que contenga la proporción de cada una de las materias"""

B2020_II_UA2['Proporcion'] = (B2020_II_UA2['Unidad de Aprendizaje']/B2020_II_UA2['Unidad de Aprendizaje'].sum())*100

"""Asignamos a la variable B2020_Proporcion_Materias_II solamente Proporción de la variable B2020_II_UA2"""

B2020_Proporcion_Materias_II = B2020_II_UA2.loc[:,'Proporcion'].to_frame()

B2020_Proporcion_Materias_II

"""### Limpieza para obtener el total de alumnos por carrera y el gráfico

Asignamos a la variable B2020_II_Carrera solamente la columna Carrera de la base de datos.
"""

B2020_II_Carrera = B2020_II.loc[:,'Carrera']

"""Asignamos a la variable B2020_II_Carrera_Total el conteo del numero de veces que se repite cada carrera"""

B2020_II_Carrera_Total = B2020_II_Carrera.value_counts().to_frame()

B2020_II_Carrera_Total

"""## $2021 - I$

### Limpieza general de la base de datos
"""

B2021_I.head(4)

"""Ya que solo tenemos las carreras de la facultad FCFM y nos quedaremos con la información correspondiente a las carreras dadas en la facultad FCFM, no hay cambios."""

B2021_I.loc[:,'Carrera'].value_counts()

"""**NOTA : Al momento de la limpieza me di cuenta que LM se repetia dos veces y esto sucedió porque se encontraba «LM » y «LM». El siguiente código es para resolver ese problema**"""

B2021_LM = B2021_I.loc[B2021_I.loc[:,'Carrera'] == 'LM '] #TODO LOS QUE TENGAS "LM " CON ESPACIO LOS PONDRÉ EN B2021_LM
B2021_LM['Carrera'].replace('LM ','LM',inplace = True) #MODIFICO TODOS ESTOS DATOS QUITANDO EL ESPACIO Y MODIFICO B2021_LM

B2021_I = pd.concat([B2021_I.drop(list(B2021_LM.index)),B2021_LM],axis=0) #QUITO LAS FILAS QUE TIENEN EL PROBLEMA Y LAS AGREGO AL DF ARREGLADO

B2021_I.loc[:,'Carrera'].value_counts()

"""Vamor a leer el tipo de dato que contiene cada columna"""

B2021_I.info()

"""Notemos que la columna 'TIEMPO (MIN)' tiene datos tipo 'int64', es decir, entero.

### Limpieza para el tiempo y gráfico (promedio y total)

Nosotros queremos calcular la media del tiempo de asesoría, primero hacemos una clasificación del tiempo pues por la manera en que estan estructurados algunos datos hace imposible la limpieza general dando como resultado tiempos negativos que no son lógicos o tiempos demasiados extensos. Por tanto la clasifación que tomaremos son aquellos tiempos de asesoría mayores a 5 minutos pero menores a 360 minutos (6 horas)

Este filtrado lo asignamos a la variable 'B2021_I_Tiempo'
"""

B2021_I_Tiempo = B2021_I.loc[ B2021_I.loc[:,'TIEMPO (MIN)'] >= 5]
B2021_I_Tiempo = B2021_I_Tiempo.loc[ B2021_I_Tiempo.loc[:,'TIEMPO (MIN)'] <= 360 ]

"""Calculamos el promedio de tiempo de asesoría con la función mean y lo asignamos a la variable 'B2021_I_Promedio_Tiempo'"""

B2021_I_Promedio_Tiempo = B2021_I_Tiempo.loc[:,'TIEMPO (MIN)'].mean()
B2021_I_Promedio_Tiempo

"""Para realizar el histograma de frecuencias solamente filtramos la columna 'TIEMPO (MIN)' y lo asignamos a la variable 'B2021_I_Hist_Tiempo'"""

B2021_I_Hist_Tiempo = B2021_I_Tiempo.loc[:,'TIEMPO (MIN)']

"""Para calcular el total de tiempo de asesoría usamos la función sum y lo asignamos a la variable 'B2021_I_Total_Tiempo'"""

B2021_I_Total_Tiempo = B2021_I_Tiempo.loc[:,'TIEMPO (MIN)'].sum()
B2021_I_Total_Tiempo

"""### Limpieza para la gráfica de pasteles

Queremos una proporción de materias, por lo tanto extraemos la columna «Unidad de Aprendizaje» y lo asignamos a la variable B2021_I_UA.
"""

B2021_I_UA = B2021_I.loc[:,'Unidad de Aprendizaje'].value_counts().to_frame() #CONTABILIZAMOS CUANTAS VECES SE REPITE CADA MATERIA Y LO HACEMOS DATA FRAME
B2021_I_UA

"""Las materias que fueron solicitadas menos de 1 vez las agregaremos a la variable B_2021_I_UA_Otros, esto lo hacemos para que el gráfico tenga una mejor estática y **NO** por el cálculo de las proporciones."""

B2021_I_UA_Otros = B2021_I_UA.loc[ B2021_I_UA.loc[:,'Unidad de Aprendizaje'] < 5 ]

"""Eliminamos del Data Frame B_2021_I_UA las materias que se solicitan menos de 1 vez"""

B2021_I_UA.drop(list(B2021_I_UA_Otros.index),inplace = True)

"""Se añade la fila 'Otros' que indicará cuantas veces la proporción de materias con una frecuencia igual a 1 """

B2021_I_UA.loc['Otros'] = B2021_I_UA_Otros.sum()
B2021_I_UA

"""### Limpieza para obtener la proporción de materias

Filtramos nuevamente la columna «Unidad de Aprendizaje», contamos el número de veces que fue solicitado una sola materia
"""

B2021_I_UA2 = B2021_I.loc[:,'Unidad de Aprendizaje'].value_counts().to_frame()

"""Contamos el número total de asesorías"""

B2021_I_UA2.loc[:,'Unidad de Aprendizaje'].sum()

"""Añadimos una nueva columna a B2021_I_UA2 llamada "Proporción" que contenga la proporción de cada una de las materias"""

B2021_I_UA2['Proporcion'] = (B2021_I_UA2['Unidad de Aprendizaje']/B2021_I_UA2['Unidad de Aprendizaje'].sum())*100

"""Asignamos a la variable «B2021_Proporcion_Materias» solamente la columna Proporción de la variable B2021_I_UA2"""

B2021_Proporcion_Materias = B2021_I_UA2.loc[:,'Proporcion'].to_frame()
B2021_Proporcion_Materias

"""### Limpieza para obtener el total de alumnos por carrera y el gráfico

Asignamos a la variable «B2021_Carrera» solamente la columna Carrera de la base de datos.
"""

B2021_Carrera = B2021_I.loc[:,'Carrera']

"""Asignamos a la variable «B2021_Carrera_Total» el conteo del numero de veces que se repite cada carrera"""

B2021_Carrera_Total = B2021_Carrera.value_counts().to_frame()
B2021_Carrera_Total

"""#Gráficas

## Gráficos de pastel

Página para ver colores de Matplotlib

[Colores Matplotlib][1]

[1]: https://matplotlib.org/stable/tutorials/colors/colormaps.html

### $2019-I$
"""

B2019_I_UA.plot(kind = 'pie', #TIPO DE GRAFICO
                figsize = (23,15),
                autopct = '%1.1f%%', 
                startangle = 45, #INCLINACION DEL PASTEL
                shadow = True, #SOMBREADO
                subplots = True, #SUBGRAFICOS
                legend = False, #NO LEYENDA
                pctdistance = 1.06, 
                colormap = 'tab20c') #COLOR, PARA VER QUE COLORES HAY VER LA PAGINA QUE DEJE EN LINK)
plt.axis('equal')
plt.tight_layout()

"""### $2019-II$"""

B2019_II_UA.plot(kind = 'pie', #TIPO DE GRAFICO
                figsize = (23,15),
                autopct = '%1.1f%%', 
                startangle = 45, #INCLINACION DEL PASTEL
                shadow = True, #SOMBREADO
                subplots = True, #SUBGRAFICOS
                legend = False, #NO LEYENDA
                pctdistance = 1.06, 
                colormap = 'tab20', #COLOR, PARA VER QUE COLORES HAY VER LA PAGINA QUE DEJE EN LINK
)
plt.axis('equal')
plt.tight_layout()

"""### $2020-I$"""

B2020_I_UA

B2020_I_UA.plot(kind = 'pie', #TIPO DE GRAFICO
                figsize = (23,15),
                autopct = '%1.1f%%', 
                startangle = 45, #INCLINACION DEL PASTEL
                shadow = True, #SOMBREADO
                subplots = True, #SUBGRAFICOS
                legend = False, #NO LEYENDA
                pctdistance = 1.06, 
                colormap = 'tab20b', #COLOR, PARA VER QUE COLORES HAY VER LA PAGINA QUE DEJE EN LINK
)
plt.axis('equal')
plt.tight_layout()

"""### $2020-II$"""

B2020_II_UA.plot(kind = 'pie', #TIPO DE GRAFICO
                figsize = (23,15),
                autopct = '%1.1f%%', 
                startangle = 45, #INCLINACION DEL PASTEL
                shadow = True, #SOMBREADO
                subplots = True, #SUBGRAFICOS
                legend = False, #NO LEYENDA
                pctdistance = 1.06, 
                colormap = 'Set1', #COLOR, PARA VER QUE COLORES HAY VER LA PAGINA QUE DEJE EN LINK
)
plt.axis('equal')
plt.tight_layout()

"""### $2021-I$"""

B2021_I_UA.plot(kind = 'pie', #TIPO DE GRAFICO
                figsize = (23,15),
                autopct = '%1.1f%%', 
                startangle = 45, #INCLINACION DEL PASTEL
                shadow = True, #SOMBREADO
                subplots = True, #SUBGRAFICOS
                legend = False, #NO LEYENDA
                pctdistance = 1.06, 
                colormap = 'Set3', #COLOR, PARA VER QUE COLORES HAY VER LA PAGINA QUE DEJE EN LINK
)
plt.axis('equal')
plt.tight_layout()

"""### Conjunto de gráficos"""

B2019_I_UA_P = B2019_I_UA.rename(columns={'UNIDAD DE APRENDIZAJE ':'2019-I'})
B2019_II_UA_P = B2019_II_UA.rename(columns={'UNIDAD DE APRENDIZAJE ':'2019-II'})
B2020_I_UA_P = B2020_I_UA.rename(columns = {'Unidad de Aprendizaje':'2020-I'})
B2020_II_UA_P = B2020_II_UA.rename(columns = {'Unidad de Aprendizaje':'2020-II'})
B2021_I_UA_P = B2021_I_UA.rename(columns = {'Unidad de Aprendizaje':'2021-I'})

fig, axes0 = plt.subplots(nrows=2, ncols=3,figsize = (27,18))
B2019_I_UA_P.plot(kind = 'pie', #TIPO DE GRAFICO
                autopct = '%1.1f%%', 
                startangle = 45, #INCLINACION DEL PASTEL
                shadow = True, #SOMBREADO
                subplots = True, #SUBGRAFICOS
                legend = False, #NO LEYENDA
                colormap = 'gist_rainbow', #COLOR, PARA VER QUE COLORES HAY VER LA PAGINA QUE DEJE EN LINK
                ax=axes0[0,0])
B2019_II_UA_P.plot(kind = 'pie', #TIPO DE GRAFICO
                autopct = '%1.1f%%', 
                startangle = 45, #INCLINACION DEL PASTEL
                shadow = True, #SOMBREADO
                subplots = True, #SUBGRAFICOS
                legend = False, #NO LEYENDA
                colormap = 'gist_rainbow', #COLOR, PARA VER QUE COLORES HAY VER LA PAGINA QUE DEJE EN LINK
                ax=axes0[0,1])
B2020_I_UA_P.plot(kind = 'pie', #TIPO DE GRAFICO
                autopct = '%1.1f%%', 
                startangle = 36, #INCLINACION DEL PASTEL
                shadow = True, #SOMBREADO
                subplots = True, #SUBGRAFICOS
                legend = False, #NO LEYENDA
                colormap = 'gist_rainbow', #COLOR, PARA VER QUE COLORES HAY VER LA PAGINA QUE DEJE EN LINK
                ax=axes0[0,2])
B2020_II_UA_P.plot(kind = 'pie', #TIPO DE GRAFICO
                autopct = '%1.1f%%', 
                startangle = 45, #INCLINACION DEL PASTEL
                shadow = True, #SOMBREADO
                subplots = True, #SUBGRAFICOS
                legend = False, #NO LEYENDA
                colormap = 'gist_rainbow', #COLOR, PARA VER QUE COLORES HAY VER LA PAGINA QUE DEJE EN LINK
                ax=axes0[1,0])
B2021_I_UA_P.plot(kind = 'pie', #TIPO DE GRAFICO
                autopct = '%1.1f%%', 
                startangle = 45, #INCLINACION DEL PASTEL
                shadow = True, #SOMBREADO
                subplots = True, #SUBGRAFICOS
                legend = False, #NO LEYENDA
                colormap = 'gist_rainbow', #COLOR, PARA VER QUE COLORES HAY VER LA PAGINA QUE DEJE EN LINK
                ax=axes0[1,1])
plt.tight_layout()
plt.savefig('Ej1.pdf',format = 'pdf')

"""## Gráficos de barras verticales

### $2019-I$
"""

B2019_Carrera_Total.plot(kind = 'bar',
                         legend = False,
                         figsize = (18,10),
                         color = 'gray',
                         edgecolor = 'black',
                         alpha = 0.35)
plt.tight_layout()

"""### $2019-II$"""

B2019_II_Carrera_Total.plot(kind = 'bar',
                         legend = False,
                         figsize = (18,10),
                         color = 'gray',
                         edgecolor = 'black',
                         alpha = 0.35)
plt.tight_layout()

"""### $2020-I$"""

B2020_I_Carrera_Total.plot(kind = 'bar',
                         legend = False,
                         figsize = (18,10),
                         color = 'gray',
                         edgecolor = 'black',
                         alpha = 0.35)
plt.tight_layout()

"""### $2020-II$"""

B2020_II_Carrera_Total.plot(kind = 'bar',
                         legend = False,
                         figsize = (18,10),
                         color = 'gray',
                         edgecolor = 'black',
                         alpha = 0.35)
plt.tight_layout()

"""### $2021-I$"""

B2021_Carrera_Total.plot(kind = 'bar',
                         legend = False,
                         figsize = (18,10),
                         color = 'gray',
                         edgecolor = 'black',
                         alpha = 0.35)
plt.tight_layout()

"""### Conjunto de gráficos"""

CGB0 = pd.concat([B2019_Carrera_Total,B2019_II_Carrera_Total],axis = 1)
CGB0.columns = ['2019-I','2019-II']
CGB1 = pd.concat([B2020_I_Carrera_Total,B2020_II_Carrera_Total],axis = 1)
CGB1.columns = ['2020-I','2020-II']
CGB2 = pd.concat([CGB0,CGB1],axis = 1)
CGB3 = pd.concat([CGB2,B2021_Carrera_Total],axis = 1)
CGB3.rename(columns = {'Carrera':'2021-I'},inplace = True)

CGB3.plot(kind = 'bar',stacked = True,figsize = (16,8),colormap = 'Set3')
plt.legend(fontsize = 'xx-large')
plt.tight_layout()
plt.savefig('Ej2.pdf',format = 'pdf')

"""## Gráficos de barras horizontales"""

plt.figure(figsize = (16,8))
plt.barh(['2019-I',
         '2019-II',
         '2020-I',
         '2020-II',
         '2021-I'],
        [B2019_I_Total_Tiempo,
        B2019_II_Total_Tiempo,
        B2020_I_Total_Tiempo,
        B2020_II_Total_Tiempo,
        B2021_I_Total_Tiempo],
         color = ['blue','red','yellow','orange','cyan'],
         edgecolor = 'black',
         alpha = 0.40)
plt.tight_layout()
plt.savefig('Ej3.pdf',format = 'pdf')

"""## Histogramas de frecuencias

### $2019-I$
"""

c, xtick_2019_I = np.histogram(B2019_I_Hist_Tiempo) #ESTA FUNCION NOS AYUDA A MOSTRAR LOS VALORES EXACTOS EN CADA INTERVALO MOSTRADO EN EL GRAFICO
B2019_I_Hist_Tiempo.plot(kind = 'hist', 
                         edgecolor = 'black', #ORILLAS NEGRAS
                         xticks = xtick_2019_I, #INTERVALOS DEL GRAFICO
                         figsize = (15,9)) #LARGO Y ALTO DEL GRAFICO
plt.tight_layout()

"""### $2019-II$"""

c, xtick_2019_II = np.histogram(B2019_II_Hist_Tiempo) #ESTA FUNCION NOS AYUDA A MOSTRAR LOS VALORES EXACTOS EN CADA INTERVALO MOSTRADO EN EL GRAFICO
B2019_II_Hist_Tiempo.plot(kind = 'hist', 
                         edgecolor = 'black', #ORILLAS NEGRAS
                         xticks = xtick_2019_II, #INTERVALOS DEL GRAFICO
                         figsize = (15,9)) #LARGO Y ALTO DEL GRAFICO
plt.tight_layout()

"""### $2020-I$"""

c, xtick_2020_I = np.histogram(B2020_I_Hist_Tiempo) #ESTA FUNCION NOS AYUDA A MOSTRAR LOS VALORES EXACTOS EN CADA INTERVALO MOSTRADO EN EL GRAFICO
B2020_I_Hist_Tiempo.plot(kind = 'hist', 
                         edgecolor = 'black', #ORILLAS NEGRAS
                         xticks = xtick_2020_I, #INTERVALOS DEL GRAFICO
                         figsize = (15,9)) #LARGO Y ALTO DEL GRAFICO
plt.tight_layout()

"""### $2020-II$"""

c, xtick_2020_II = np.histogram(B2020_II_Hist_Tiempo) #ESTA FUNCION NOS AYUDA A MOSTRAR LOS VALORES EXACTOS EN CADA INTERVALO MOSTRADO EN EL GRAFICO
B2020_II_Hist_Tiempo.plot(kind = 'hist', 
                         edgecolor = 'black', #ORILLAS NEGRAS
                         xticks = xtick_2019_II, #INTERVALOS DEL GRAFICO
                         figsize = (15,9)) #LARGO Y ALTO DEL GRAFICO
plt.tight_layout()

"""### $2021-I$"""

c, xtick_2021_I = np.histogram(B2021_I_Hist_Tiempo) #ESTA FUNCION NOS AYUDA A MOSTRAR LOS VALORES EXACTOS EN CADA INTERVALO MOSTRADO EN EL GRAFICO
B2021_I_Hist_Tiempo.plot(kind = 'hist', 
                         edgecolor = 'black', #ORILLAS NEGRAS
                         xticks = xtick_2021_I, #INTERVALOS DEL GRAFICO
                         figsize = (15,9)) #LARGO Y ALTO DEL GRAFICO
plt.tight_layout()

"""### Media de los datos agrupados

La siguiente función nos ayuda a calcular la media de los datos agrupados
"""

def mean_da (Frecuencia,Marca_Clase):
  '''
  Frecuencia : Es la columna del Data Frame de los datos agrupados que contiene la frecuencia del intervalo

  Marca_Clase : Es la columna del Data Frame de los datos agrupados que contiene la marca de clase del intervalo
  '''
  Media = 0
  for i in range (len(Frecuencia)):
    Media += Frecuencia.iloc[i]*Marca_Clase.iloc[i]
  return Media/sum(Frecuencia)

"""Vamos a generar la tabla de frecuencia de cada una de las bases con enfoque en el tiempo"""

Hist0 = pd.cut(B2019_I_Hist_Tiempo,bins = 10)
Hist1 = pd.cut(B2019_II_Hist_Tiempo,bins = 10)
Hist2 = pd.cut(B2020_I_Hist_Tiempo,bins = 10)
Hist3 = pd.cut(B2020_II_Hist_Tiempo,bins = 10)
Hist4 = pd.cut(B2021_I_Hist_Tiempo,bins = 10)

TF0 = Hist0.to_frame().groupby('TIEMPO (MIN)').agg(frequency=("TIEMPO (MIN)", "count"))
TF1 = Hist1.to_frame().groupby('TIEMPO (MIN)').agg(frequency=("TIEMPO (MIN)", "count"))
TF2 = Hist2.to_frame().groupby('TIEMPO (MIN)').agg(frequency=("TIEMPO (MIN)", "count"))
TF3 = Hist3.to_frame().groupby('TIEMPO_(MIN)').agg(frequency=("TIEMPO_(MIN)", "count"))
TF4 = Hist4.to_frame().groupby('TIEMPO (MIN)').agg(frequency=("TIEMPO (MIN)", "count"))

TF0['Marca de Clase'] = list( (Intervalo0.left+Intervalo0.right)/2 for Intervalo0 in list(TF0.index))
TF1['Marca de Clase'] = list( (Intervalo1.left+Intervalo1.right)/2 for Intervalo1 in list(TF1.index))
TF2['Marca de Clase'] = list( (Intervalo2.left+Intervalo2.right)/2 for Intervalo2 in list(TF2.index))
TF3['Marca de Clase'] = list( (Intervalo3.left+Intervalo3.right)/2 for Intervalo3 in list(TF3.index))
TF4['Marca de Clase'] = list( (Intervalo4.left+Intervalo4.right)/2 for Intervalo4 in list(TF4.index))

"""### Conjunto de gráficos"""

#mean_da(TF0.loc[:,'frequency'],TF0.loc[:,'Marca de Clase']) #2019-I
#mean_da(TF1.loc[:,'frequency'],TF1.loc[:,'Marca de Clase']) #2019-II
#mean_da(TF2.loc[:,'frequency'],TF2.loc[:,'Marca de Clase']) #2020-I
#mean_da(TF3.loc[:,'frequency'],TF3.loc[:,'Marca de Clase']) #2020-II
#mean_da(TF4.loc[:,'frequency'],TF4.loc[:,'Marca de Clase']) #2021-I

plt.figure(figsize = (27,18))
plt.subplot(231)
c, xtick_2019_I = np.histogram(B2019_I_Hist_Tiempo)
B2019_I_Hist_Tiempo.plot(kind = 'hist', 
                         edgecolor = 'black',
                         xticks = xtick_2019_I,
                         title = 'Histograma '+r'$2019-I$',
                         alpha = 0.45)
plt.axvline(x=mean_da(TF0.loc[:,'frequency'],TF0.loc[:,'Marca de Clase']), ymin=0, ymax=100,color = 'red',linestyle = '--')

plt.subplot(232)
c, xtick_2019_II = np.histogram(B2019_II_Hist_Tiempo)
B2019_II_Hist_Tiempo.plot(kind = 'hist', 
                         edgecolor = 'black', 
                         xticks = xtick_2019_II,
                         title = 'Histograma '+r'$2019 - II$',
                          alpha = 0.45) 
plt.axvline(x=mean_da(TF1.loc[:,'frequency'],TF1.loc[:,'Marca de Clase']),ymin=0,ymax=100,color = 'red',linestyle='--')

plt.subplot(233)
c, xtick_2020_I = np.histogram(B2020_I_Hist_Tiempo)
B2020_I_Hist_Tiempo.plot(kind = 'hist', 
                         edgecolor = 'black',
                         xticks = xtick_2020_I,
                         title = 'Histograma '+r'$2020 - I$',
                         alpha = 0.45)
plt.axvline(x=mean_da(TF2.loc[:,'frequency'],TF2.loc[:,'Marca de Clase']),ymin=0,ymax=100,color = 'red',linestyle='--')

plt.subplot(234)
c, xtick_2020_II = np.histogram(B2020_II_Hist_Tiempo) 
B2020_II_Hist_Tiempo.plot(kind = 'hist', 
                         edgecolor = 'black',
                         xticks = xtick_2019_II,
                         title = 'Histograma '+r'$2020 - II$',
                          alpha = 0.45)
plt.axvline(x=mean_da(TF3.loc[:,'frequency'],TF3.loc[:,'Marca de Clase']),ymin=0,ymax=100,color = 'red',linestyle='--')

plt.subplot(235)
c, xtick_2021_I = np.histogram(B2021_I_Hist_Tiempo) 
B2021_I_Hist_Tiempo.plot(kind = 'hist', 
                         edgecolor = 'black', 
                         xticks = xtick_2021_I,
                         title = 'Histograma '+r'$2021 - I$',
                         alpha = 0.45)
plt.axvline(x=mean_da(TF4.loc[:,'frequency'],TF4.loc[:,'Marca de Clase']),ymin=0,ymax=100,color = 'red',linestyle='--')
plt.tight_layout()
plt.savefig('Ej4.pdf',format = 'pdf')

"""# Tablas

## Tiempo promedio de asesoría
"""

Tabla_Tiempo_Promedio = pd.DataFrame({'Año-Semestre':['2019-I','2019-II','2020-I','2020-II','2021-I'],
                                      'Tiempo Promedio (Minutos)':[B2019_I_Promedio_Tiempo,
                                                                  B2019_II_Promedio_Tiempo,
                                                                  B2020_I_Promedio_Tiempo,
                                                                  B2020_II_Promedio_Tiempo,
                                                                  B2021_I_Promedio_Tiempo]})

Tabla_Tiempo_Promedio

"""## Tiempo total de asesoría"""

Tabla_Tiempo_Total = pd.DataFrame({'Año-Semestre':['2019-I','2019-II','2020-I','2020-II','2021-I'],
                                   'Tiempo Total (Minutos)':[B2019_I_Total_Tiempo,
                                                             B2019_II_Total_Tiempo,
                                                             B2020_I_Total_Tiempo,
                                                             B2020_II_Total_Tiempo,
                                                             B2021_I_Total_Tiempo]})

Tabla_Tiempo_Total

"""## Total de alumnos por carrera"""

CGB3

"""#Análisis Extras

## Prueba de *Kolmogorov-Smirnov* a dos muestras
"""

!pip install scipy --upgrade

from scipy.stats import ks_2samp

"""Tomaremos $\alpha = 0.05$

Vamos a comprobar que la distribución de tiempo en $2019-I$ con los demás semestres
"""

ks_2samp(B2019_I_Hist_Tiempo,B2019_II_Hist_Tiempo) #B2019-II

ks_2samp(B2019_I_Hist_Tiempo,B2020_I_Hist_Tiempo) #B2020-I

ks_2samp(B2019_I_Hist_Tiempo,B2020_II_Hist_Tiempo) #B2020-II

ks_2samp(B2019_I_Hist_Tiempo,B2021_I_Hist_Tiempo) #B2021-I

"""Comprobamos que la distribución de tiempo en $2019-II$ con los demás semestres"""

ks_2samp(B2019_II_Hist_Tiempo,B2020_I_Hist_Tiempo) #B2020-I

ks_2samp(B2019_II_Hist_Tiempo,B2020_II_Hist_Tiempo) #B2020-II

ks_2samp(B2019_II_Hist_Tiempo,B2021_I_Hist_Tiempo) #B2021-I

"""Comprobamos que la distribución de tiempo en $2020-I$ con los demás semestres"""

ks_2samp(B2020_I_Hist_Tiempo,B2020_II_Hist_Tiempo) #B2020-II

ks_2samp(B2020_I_Hist_Tiempo,B2021_I_Hist_Tiempo) #B2021-I

"""Comprobamos que la distribución de tiempo en $2020-II$ con los demás semestres"""

ks_2samp(B2020_II_Hist_Tiempo,B2021_I_Hist_Tiempo) #B2021-I

"""## Data Classification"""

Data0 = B2019_I.loc[:,['CARRERA','UNIDAD DE APRENDIZAJE ','TIEMPO (MIN)']]
Data1 = B2019_II.loc[:,['CARRERA','UNIDAD DE APRENDIZAJE ','TIEMPO (MIN)']]
Data2 = B2020_I.loc[:,['Carrera','Unidad de Aprendizaje','TIEMPO (MIN)']]
Data3 = B2020_II.loc[:,['Carrera','Unidad de Aprendizaje','TIEMPO_(MIN)']]
Data4 = B2021_I.loc[:,['Carrera','Unidad de Aprendizaje','TIEMPO (MIN)']]

Data0.rename(columns = {'UNIDAD DE APRENDIZAJE ':'UNIDAD DE APRENDIZAJE'},inplace = True)
Data1.rename(columns = {'UNIDAD DE APRENDIZAJE ':'UNIDAD DE APRENDIZAJE'},inplace = True)
Data2.rename(columns = {'Unidad de Aprendizaje':'UNIDAD DE APRENDIZAJE','Carrera':'CARRERA'},inplace = True)
Data3.rename(columns = {'Unidad de Aprendizaje':'UNIDAD DE APRENDIZAJE','Carrera':'CARRERA','TIEMPO_(MIN)':'TIEMPO (MIN)'},inplace = True)
Data4.rename(columns = {'Unidad de Aprendizaje':'UNIDAD DE APRENDIZAJE','Carrera':'CARRERA'},inplace = True)

Data = pd.concat([Data0,Data1],ignore_index = True)
Data = pd.concat([Data,Data2],ignore_index= True)
Data = pd.concat([Data,Data3],ignore_index=True)
Data = pd.concat([Data,Data4],ignore_index=True)
Data

"""Nos interesa estimar que dado el tiempo de asesoría y si pide un estudiante 'Probabilidad' sea estudiante de Actuaría

Como tenemos variables cualitativas en las columnas de 'CARRERA' y 'UNIDAD DE APRENDIZAJE' los volvemos binarias y los agrupamos en un solo Data Frame
"""

DC = pd.concat([pd.get_dummies(Data.loc[:,'CARRERA']).loc[:,'LA'].to_frame(),pd.get_dummies(Data.loc[:,'UNIDAD DE APRENDIZAJE']).loc[:,'Probabilidad'].to_frame()],axis = 1,ignore_index=True)
DC = pd.concat([ DC,Data.loc[:,'TIEMPO (MIN)'] ],axis = 1,ignore_index = True)
DC.columns = ['LA','Probabilidad','TIEMPO (MIN)']

DC

DC.dropna(inplace=True)

X_ = DC[['TIEMPO (MIN)','Probabilidad']]
Y_ = DC['LA']

!pip install sklearn --upgrade

from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier

"""Vamos asignar el $30\%$ de los datos a las pruebas"""

X_train, X_test, Y_train, Y_test = train_test_split(X_,Y_,test_size = 0.3)

"""Crearemos una variable llamada 'vecinos' para ir incrementando el número de vecinos a estudiar y su exactitud, iremos desde 1 hasta 100 vecinos"""

vecinos = list(range(1,101))

train_exactitud = np.empty(len(vecinos))
test_exactitud = np.empty(len(vecinos))

"""Creamos el ciclo for que nos ayuda a entrenar el modelo en cada iteracion en función"""

for it1, it2 in enumerate(vecinos):
  knn = KNeighborsClassifier(n_neighbors=it2)
  knn.fit(X_train,Y_train)
  train_exactitud[it1] = knn.score(X_train,Y_train)
  test_exactitud[it1] = knn.score(X_test,Y_test)

"""Graficamos"""

grafo = pd.DataFrame({'Test Exactitud':list(test_exactitud),'Entrenamiento':list(train_exactitud)})

grafo.plot(kind = 'area',figsize = (16,7),stacked = False, ylim = (0.55,0.68),alpha = 0.35,xlim = (0,100),legend = False)
plt.title('Variacion vecinos en KNN')
plt.legend(fontsize = 'x-large')
plt.xlabel('Vecinos')
plt.ylabel('Exactitud')
plt.tight_layout()
plt.savefig('Grafico_Area.pdf',format = 'pdf')

"""Vamos a predecir un valor tomando 30 vecinos, 40 minutos de asesoría y si tomó probabilidad (1)."""

knn = KNeighborsClassifier(n_neighbors=30)
knn.fit(X_train,Y_train)
pred1 = knn.predict([[40,1]])

"""Exactitud que tendremos con el valor resultado"""

knn.score(X_test,Y_test)

"""Valor resultado"""

if pred1[0] == 1:
  print('Actuario')
else:
  print('Otra carrera de FCFM')